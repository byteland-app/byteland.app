{"pageProps":{"post":{"content":"\nWe're excited to announce the release of **ink-scroll-view**, a new open-source library that brings smooth, glitch-free scrolling to terminal applications built with [Ink](https://github.com/vadimdemedes/ink).\n\n## Why We Built This\n\nIf you've ever tried to build a CLI tool with Ink, you've likely hit a wall: **there's no built-in way to scroll content**. Ink gives you powerful React primitives like `<Box>` and `<Text>`, but when your content exceeds the terminal height, you're on your own.\n\nWe needed a reliable scrolling solution for our own CLI tools, so we built one â€” and now we're sharing it with the community.\n\n**ink-scroll-view** provides:\n\n- ðŸš€ **High-performance scrolling** â€” Uses a \"negative margin\" technique instead of string slicing, minimizing re-renders\n- ðŸŽ¯ **Smart alignment** â€” Scroll to any item with `auto`, `top`, `center`, or `bottom` alignment\n- ðŸ“ **Dynamic content support** â€” Handles variable-height items and runtime content changes seamlessly\n- âš¡ **Zero flicker** â€” Smooth scrolling without visual glitches\n\n## The Engineering Challenges\n\nBuilding a scroll view in a CLI environment presents unique constraints compared to the web:\n\n1.  **No Native \"Scroll\" Property**: Terminal buffers are linear streams. You cannot simply set `scrollTop = 100`. To \"scroll\", you must fundamentally alter _what_ text is sent to the output buffer.\n2.  **Layout Dependency**: To scroll correctly, you need to know the precise height of the content _before_ you decide which slice of it to show. However, in React, layout measurements usually happen _after_ the render commit phase.\n3.  **Clipping**: You need to mask content that is \"out of view\" without breaking the layout calculations of the content that _is_ in view. Simply not rendering the children means their dimensions cannot be measured.\n\n## The Solution: The \"Negative Margin\" Viewport\n\nOur solution leverages Ink's exposure of Yoga layout metrics combined with a classic \"sliding window\" technique.\n\n### 1. Visualizing the Architecture\n\nInstead of manually slicing strings, we render the _entire_ content list but shift its position vertically within a clipped container.\n\n![Scroll Architecture](./introducing-ink-scroll-view/scroll-architecture.svg)\n\nThe implementation relies on three nested layers:\n\n1.  **Viewport (Outer Box)**: Fixed `height`, `overflowY: \"hidden\"`. This clips content.\n2.  **Container (Inner Box)**: `marginTop: -scrollTop`. This shifts content up.\n3.  **Items**: The actual content.\n\nThe Layout Engine (Yoga) calculates the positions of _all_ items. Ink then renders the Container shifted upwards. The Viewport discards any lines that physically fall outside its 0 to `height` range.\n\n### 2. Reactivity: Handling Dynamic Content\n\nIn a terminal, window resizing and dynamic data loading are common. If the data changes (e.g., a log line is added) or the component changes size (e.g., an accordion expands), the scroll position must remain valid.\n\n**The Challenge:** React renders first, _then_ Ink/Yoga calculates layout. We don't know the height of an item until _after_ it has been rendered to the virtual DOM.\n\n**The Solution:**\n\n1.  **Initial Measurement**:\n    Every direct child is wrapped in a `MeasurableItem` component that hooks into Ink's `measureElement` to report its height.\n\n    ```tsx\n    useLayoutEffect(() => {\n      const { height } = measureElement(ref.current);\n      onMeasure(index, height);\n    }, [width, children]); // Re-run if width or content changes\n    ```\n\n2.  **Responding to Dynamic Changes**:\n    Content and layout can change at runtime. Two APIs handle re-measurement:\n    - `remeasure()`: Call this when the ScrollView's container size changes (e.g., terminal resize). Items re-layout automatically, but ScrollView needs this trigger to recalculate.\n    - `remeasureItem(index)`: Call this when a specific item's content changes. This notifies ScrollView to re-measure that item.\n\n3.  **Bounds Clamping**:\n    Whenever item heights update, we recalculate `maxScroll` (`totalContentHeight - viewportHeight`). If the current scroll position becomes invalid (e.g., items were deleted), we automatically clamp it to a valid range.\n\n### 3. Smart Scrolling: Alignment Strategies\n\nA critical feature of `ScrollList` is its ability to intelligently scroll to an item. We support four alignment modes: `auto`, `top`, `bottom`, and `center`.\n\n#### Mode: `auto` (Default)\n\nThe \"least intrusive\" scroll.\n\n**If the item is below the viewport**, we scroll just enough to show it at the **bottom**:\n\n![Auto Below](./introducing-ink-scroll-view/auto-below.svg)\n\n**If the item is above the viewport**, we scroll just enough to show it at the **top**:\n\n![Auto Above](./introducing-ink-scroll-view/auto-above.svg)\n\n**If it's already visible**, we do nothing:\n\n![Auto Visible](./introducing-ink-scroll-view/auto-visible.svg)\n\n#### Forced Alignments\n\nSometimes you want precise control, like centering a search result or jumping to the top of a list.\n\n**`top`**: Always align item to the top of the viewport.\n\n![Align Top](./introducing-ink-scroll-view/align-top.svg)\n\n**`bottom`**: Always align item to the bottom of the viewport.\n\n![Align Bottom](./introducing-ink-scroll-view/align-bottom.svg)\n\n**`center`**: Always align item to the center of the viewport.\n\n![Align Center](./introducing-ink-scroll-view/align-center.svg)\n\n**The Algorithm:**\n\n1.  **Get Metrics**: Retrieve the `top`, `height`, and `bottom` of the target item relative to the full content list.\n2.  **Apply Logic**: Calculate the new `scrollOffset` based on the chosen alignment strategy as visualized above.\n3.  **Clamp**: Ensure the new offset is within valid bounds (`0` to `maxScroll`).\n\n## Summary\n\n`ink-scroll-view` bridges the gap between web-like development DX and the constraints of terminal rendering.\n\n- It uses **negative margins** to emulate scrolling.\n- It performs **O(1)** lookups for item positioning to handle navigation efficiently.\n- It uses **reactive measurement hooks** to support dynamic content and variable-height items seamlessly.\n\nBy solving these low-level engineering problems, developers can focus on building rich, interactive CLI tools.\n","mdxSource":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"We're excited to announce the release of \", _jsx(_components.strong, {\n        children: \"ink-scroll-view\"\n      }), \", a new open-source library that brings smooth, glitch-free scrolling to terminal applications built with \", _jsx(_components.a, {\n        href: \"https://github.com/vadimdemedes/ink\",\n        children: \"Ink\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why We Built This\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you've ever tried to build a CLI tool with Ink, you've likely hit a wall: \", _jsx(_components.strong, {\n        children: \"there's no built-in way to scroll content\"\n      }), \". Ink gives you powerful React primitives like \", _jsx(_components.code, {\n        children: \"<Box>\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"<Text>\"\n      }), \", but when your content exceeds the terminal height, you're on your own.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We needed a reliable scrolling solution for our own CLI tools, so we built one â€” and now we're sharing it with the community.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"ink-scroll-view\"\n      }), \" provides:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"ðŸš€ \", _jsx(_components.strong, {\n          children: \"High-performance scrolling\"\n        }), \" â€” Uses a \\\"negative margin\\\" technique instead of string slicing, minimizing re-renders\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"ðŸŽ¯ \", _jsx(_components.strong, {\n          children: \"Smart alignment\"\n        }), \" â€” Scroll to any item with \", _jsx(_components.code, {\n          children: \"auto\"\n        }), \", \", _jsx(_components.code, {\n          children: \"top\"\n        }), \", \", _jsx(_components.code, {\n          children: \"center\"\n        }), \", or \", _jsx(_components.code, {\n          children: \"bottom\"\n        }), \" alignment\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"ðŸ“ \", _jsx(_components.strong, {\n          children: \"Dynamic content support\"\n        }), \" â€” Handles variable-height items and runtime content changes seamlessly\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"âš¡ \", _jsx(_components.strong, {\n          children: \"Zero flicker\"\n        }), \" â€” Smooth scrolling without visual glitches\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"The Engineering Challenges\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Building a scroll view in a CLI environment presents unique constraints compared to the web:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"No Native \\\"Scroll\\\" Property\"\n        }), \": Terminal buffers are linear streams. You cannot simply set \", _jsx(_components.code, {\n          children: \"scrollTop = 100\"\n        }), \". To \\\"scroll\\\", you must fundamentally alter \", _jsx(_components.em, {\n          children: \"what\"\n        }), \" text is sent to the output buffer.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Layout Dependency\"\n        }), \": To scroll correctly, you need to know the precise height of the content \", _jsx(_components.em, {\n          children: \"before\"\n        }), \" you decide which slice of it to show. However, in React, layout measurements usually happen \", _jsx(_components.em, {\n          children: \"after\"\n        }), \" the render commit phase.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Clipping\"\n        }), \": You need to mask content that is \\\"out of view\\\" without breaking the layout calculations of the content that \", _jsx(_components.em, {\n          children: \"is\"\n        }), \" in view. Simply not rendering the children means their dimensions cannot be measured.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"The Solution: The \\\"Negative Margin\\\" Viewport\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Our solution leverages Ink's exposure of Yoga layout metrics combined with a classic \\\"sliding window\\\" technique.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"1. Visualizing the Architecture\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead of manually slicing strings, we render the \", _jsx(_components.em, {\n        children: \"entire\"\n      }), \" content list but shift its position vertically within a clipped container.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/scroll-architecture.svg\",\n        alt: \"Scroll Architecture\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The implementation relies on three nested layers:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Viewport (Outer Box)\"\n        }), \": Fixed \", _jsx(_components.code, {\n          children: \"height\"\n        }), \", \", _jsx(_components.code, {\n          children: \"overflowY: \\\"hidden\\\"\"\n        }), \". This clips content.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Container (Inner Box)\"\n        }), \": \", _jsx(_components.code, {\n          children: \"marginTop: -scrollTop\"\n        }), \". This shifts content up.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Items\"\n        }), \": The actual content.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Layout Engine (Yoga) calculates the positions of \", _jsx(_components.em, {\n        children: \"all\"\n      }), \" items. Ink then renders the Container shifted upwards. The Viewport discards any lines that physically fall outside its 0 to \", _jsx(_components.code, {\n        children: \"height\"\n      }), \" range.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2. Reactivity: Handling Dynamic Content\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In a terminal, window resizing and dynamic data loading are common. If the data changes (e.g., a log line is added) or the component changes size (e.g., an accordion expands), the scroll position must remain valid.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"The Challenge:\"\n      }), \" React renders first, \", _jsx(_components.em, {\n        children: \"then\"\n      }), \" Ink/Yoga calculates layout. We don't know the height of an item until \", _jsx(_components.em, {\n        children: \"after\"\n      }), \" it has been rendered to the virtual DOM.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"The Solution:\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Initial Measurement\"\n          }), \":\\nEvery direct child is wrapped in a \", _jsx(_components.code, {\n            children: \"MeasurableItem\"\n          }), \" component that hooks into Ink's \", _jsx(_components.code, {\n            children: \"measureElement\"\n          }), \" to report its height.\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-tsx\",\n            children: \"useLayoutEffect(() => {\\n  const { height } = measureElement(ref.current);\\n  onMeasure(index, height);\\n}, [width, children]); // Re-run if width or content changes\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Responding to Dynamic Changes\"\n          }), \":\\nContent and layout can change at runtime. Two APIs handle re-measurement:\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.code, {\n              children: \"remeasure()\"\n            }), \": Call this when the ScrollView's container size changes (e.g., terminal resize). Items re-layout automatically, but ScrollView needs this trigger to recalculate.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.code, {\n              children: \"remeasureItem(index)\"\n            }), \": Call this when a specific item's content changes. This notifies ScrollView to re-measure that item.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Bounds Clamping\"\n          }), \":\\nWhenever item heights update, we recalculate \", _jsx(_components.code, {\n            children: \"maxScroll\"\n          }), \" (\", _jsx(_components.code, {\n            children: \"totalContentHeight - viewportHeight\"\n          }), \"). If the current scroll position becomes invalid (e.g., items were deleted), we automatically clamp it to a valid range.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3. Smart Scrolling: Alignment Strategies\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A critical feature of \", _jsx(_components.code, {\n        children: \"ScrollList\"\n      }), \" is its ability to intelligently scroll to an item. We support four alignment modes: \", _jsx(_components.code, {\n        children: \"auto\"\n      }), \", \", _jsx(_components.code, {\n        children: \"top\"\n      }), \", \", _jsx(_components.code, {\n        children: \"bottom\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"center\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      children: [\"Mode: \", _jsx(_components.code, {\n        children: \"auto\"\n      }), \" (Default)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The \\\"least intrusive\\\" scroll.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"If the item is below the viewport\"\n      }), \", we scroll just enough to show it at the \", _jsx(_components.strong, {\n        children: \"bottom\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/auto-below.svg\",\n        alt: \"Auto Below\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"If the item is above the viewport\"\n      }), \", we scroll just enough to show it at the \", _jsx(_components.strong, {\n        children: \"top\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/auto-above.svg\",\n        alt: \"Auto Above\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"If it's already visible\"\n      }), \", we do nothing:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/auto-visible.svg\",\n        alt: \"Auto Visible\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Forced Alignments\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sometimes you want precise control, like centering a search result or jumping to the top of a list.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"top\"\n        })\n      }), \": Always align item to the top of the viewport.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/align-top.svg\",\n        alt: \"Align Top\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"bottom\"\n        })\n      }), \": Always align item to the bottom of the viewport.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/align-bottom.svg\",\n        alt: \"Align Bottom\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"center\"\n        })\n      }), \": Always align item to the center of the viewport.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"./introducing-ink-scroll-view/align-center.svg\",\n        alt: \"Align Center\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"The Algorithm:\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Get Metrics\"\n        }), \": Retrieve the \", _jsx(_components.code, {\n          children: \"top\"\n        }), \", \", _jsx(_components.code, {\n          children: \"height\"\n        }), \", and \", _jsx(_components.code, {\n          children: \"bottom\"\n        }), \" of the target item relative to the full content list.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Apply Logic\"\n        }), \": Calculate the new \", _jsx(_components.code, {\n          children: \"scrollOffset\"\n        }), \" based on the chosen alignment strategy as visualized above.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Clamp\"\n        }), \": Ensure the new offset is within valid bounds (\", _jsx(_components.code, {\n          children: \"0\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"maxScroll\"\n        }), \").\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Summary\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"ink-scroll-view\"\n      }), \" bridges the gap between web-like development DX and the constraints of terminal rendering.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"It uses \", _jsx(_components.strong, {\n          children: \"negative margins\"\n        }), \" to emulate scrolling.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"It performs \", _jsx(_components.strong, {\n          children: \"O(1)\"\n        }), \" lookups for item positioning to handle navigation efficiently.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"It uses \", _jsx(_components.strong, {\n          children: \"reactive measurement hooks\"\n        }), \" to support dynamic content and variable-height items seamlessly.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By solving these low-level engineering problems, developers can focus on building rich, interactive CLI tools.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Introducing ink-scroll-view","date":"2025-12-06","tags":["Ink","CLI","React","Typescript"],"author":"The ByteLand Engineering Team","slug":"2025-12/introducing-ink-scroll-view"}},"__N_SSG":true}