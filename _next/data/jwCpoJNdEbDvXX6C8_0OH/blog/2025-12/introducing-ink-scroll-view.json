{"pageProps":{"post":{"content":"\nWe're excited to announce the release of **ink-scroll-view**, a new open-source library that brings smooth, glitch-free scrolling to terminal applications built with [Ink](https://github.com/vadimdemedes/ink).\n\n## Why We Built This\n\nIf you've ever tried to build a CLI tool with Ink, you've likely hit a wall: **there's no built-in way to scroll content**. Ink gives you powerful React primitives like `<Box>` and `<Text>`, but when your content exceeds the terminal height, you're on your own.\n\nWe needed a reliable scrolling solution for our own CLI tools, so we built one â€” and now we're sharing it with the community.\n\n**ink-scroll-view** provides:\n\n- ðŸš€ **High-performance scrolling** â€” Uses a \"negative margin\" technique instead of string slicing, minimizing re-renders\n- ðŸŽ¯ **Smart alignment** â€” Scroll to any item with `auto`, `top`, `center`, or `bottom` alignment\n- ðŸ“ **Dynamic content support** â€” Handles variable-height items and runtime content changes seamlessly\n- âš¡ **Zero flicker** â€” Smooth scrolling without visual glitches\n\n## The Engineering Challenges\n\nBuilding a scroll view in a CLI environment presents unique constraints compared to the web:\n\n1.  **No Native \"Scroll\" Property**: Terminal buffers are linear streams. You cannot simply set `scrollTop = 100`. To \"scroll\", you must fundamentally alter _what_ text is sent to the output buffer.\n2.  **Layout Dependency**: To scroll correctly, you need to know the precise height of the content _before_ you decide which slice of it to show. However, in React, layout measurements usually happen _after_ the render commit phase.\n3.  **Clipping**: You need to mask content that is \"out of view\" without breaking the layout calculations of the content that _is_ in view. Simply not rendering the children means their dimensions cannot be measured.\n\n## The Solution: The \"Negative Margin\" Viewport\n\nOur solution leverages Ink's exposure of Yoga layout metrics combined with a classic \"sliding window\" technique.\n\n### 1. Visualizing the Architecture\n\nInstead of manually slicing strings, we render the _entire_ content list but shift its position vertically within a clipped container.\n\n![Scroll Architecture](./introducing-ink-scroll-view/scroll-architecture.svg)\n\nThe implementation relies on three nested layers:\n\n1.  **Viewport (Outer Box)**: Fixed `height`, `overflowY: \"hidden\"`. This clips content.\n2.  **Container (Inner Box)**: `marginTop: -scrollTop`. This shifts content up.\n3.  **Items**: The actual content.\n\nThe Layout Engine (Yoga) calculates the positions of _all_ items. Ink then renders the Container shifted upwards. The Viewport discards any lines that physically fall outside its 0 to `height` range.\n\n### 2. Reactivity: Handling Dynamic Content\n\nIn a terminal, window resizing and dynamic data loading are common. If the data changes (e.g., a log line is added) or the component changes size (e.g., an accordion expands), the scroll position must remain valid.\n\n**The Challenge:** React renders first, _then_ Ink/Yoga calculates layout. We don't know the height of an item until _after_ it has been rendered to the virtual DOM.\n\n**The Solution:**\n\n1.  **Initial Measurement**:\n    Every direct child is wrapped in a `MeasurableItem` component that hooks into Ink's `measureElement` to report its height.\n\n    ```tsx\n    useLayoutEffect(() => {\n      const { height } = measureElement(ref.current);\n      onMeasure(index, height);\n    }, [width, children]); // Re-run if width or content changes\n    ```\n\n2.  **Responding to Dynamic Changes**:\n    Content and layout can change at runtime. Two APIs handle re-measurement:\n    - `remeasure()`: Call this when the ScrollView's container size changes (e.g., terminal resize). Items re-layout automatically, but ScrollView needs this trigger to recalculate.\n    - `remeasureItem(index)`: Call this when a specific item's content changes. This notifies ScrollView to re-measure that item.\n\n3.  **Bounds Clamping**:\n    Whenever item heights update, we recalculate `maxScroll` (`totalContentHeight - viewportHeight`). If the current scroll position becomes invalid (e.g., items were deleted), we automatically clamp it to a valid range.\n\n### 3. Smart Scrolling: Alignment Strategies\n\nA critical feature of `ScrollList` is its ability to intelligently scroll to an item. We support four alignment modes: `auto`, `top`, `bottom`, and `center`.\n\n#### Mode: `auto` (Default)\n\nThe \"least intrusive\" scroll.\n\n**If the item is below the viewport**, we scroll just enough to show it at the **bottom**:\n\n![Auto Below](./introducing-ink-scroll-view/auto-below.svg)\n\n**If the item is above the viewport**, we scroll just enough to show it at the **top**:\n\n![Auto Above](./introducing-ink-scroll-view/auto-above.svg)\n\n**If it's already visible**, we do nothing:\n\n![Auto Visible](./introducing-ink-scroll-view/auto-visible.svg)\n\n#### Forced Alignments\n\nSometimes you want precise control, like centering a search result or jumping to the top of a list.\n\n**`top`**: Always align item to the top of the viewport.\n\n![Align Top](./introducing-ink-scroll-view/align-top.svg)\n\n**`bottom`**: Always align item to the bottom of the viewport.\n\n![Align Bottom](./introducing-ink-scroll-view/align-bottom.svg)\n\n**`center`**: Always align item to the center of the viewport.\n\n![Align Center](./introducing-ink-scroll-view/align-center.svg)\n\n**The Algorithm:**\n\n1.  **Get Metrics**: Retrieve the `top`, `height`, and `bottom` of the target item relative to the full content list.\n2.  **Apply Logic**: Calculate the new `scrollOffset` based on the chosen alignment strategy as visualized above.\n3.  **Clamp**: Ensure the new offset is within valid bounds (`0` to `maxScroll`).\n\n## Summary\n\n`ink-scroll-view` bridges the gap between web-like development DX and the constraints of terminal rendering.\n\n- It uses **negative margins** to emulate scrolling.\n- It performs **O(1)** lookups for item positioning to handle navigation efficiently.\n- It uses **reactive measurement hooks** to support dynamic content and variable-height items seamlessly.\n\nBy solving these low-level engineering problems, developers can focus on building rich, interactive CLI tools.\n","title":"Introducing ink-scroll-view","date":"2025-12-06","tags":["Ink","CLI","React","Typescript"],"author":"The ByteLand Engineering Team","slug":"2025-12/introducing-ink-scroll-view"}},"__N_SSG":true}